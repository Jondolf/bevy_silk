use crate::config::ClothConfig;
use bevy::ecs::component::Component;
use bevy::log;
use bevy::math::{Mat4, Vec3};
use bevy::render::mesh::{Indices, Mesh, VertexAttributeValues};
use bevy::utils::{HashMap, HashSet};

macro_rules! get_point {
    ($id:expr, $points:expr, $fixed_points:expr, $matrix:expr) => {
        match $points.get($id) {
            None => {
                log::warn!("Failed to retrieve a Cloth point at index {}", $id);
                continue;
            }
            Some(p) => {
                if $fixed_points.contains(&$id) {
                    ($matrix.transform_point3(*p), true)
                } else {
                    (*p, false)
                }
            }
        }
    };
}

/// Defines how the cloth will compute sticks from mesh indices.
#[derive(Debug, Copy, Clone)]
pub enum StickGeneration {
    /// 3 sticks will be generated by triangle
    Triangles,
    /// 2 sticks will be generated by triangle, following the actual quad edges
    Quads,
}

impl Default for StickGeneration {
    fn default() -> Self {
        Self::Quads
    }
}

/// Cloth component
#[derive(Debug, Clone, Component, Default)]
#[must_use]
pub struct Cloth {
    /// cloth points unaffected by physics and following the attached `GlobalTransform`.
    pub fixed_points: HashSet<usize>,
    /// Current Cloth points 3D positions in world space
    current_point_positions: Vec<Vec3>,
    /// Old Cloth points 3D positions in world space
    previous_point_positions: Vec<Vec3>,
    /// Cloth sticks linking points
    ///
    /// * key: tuple with the connected points indexes
    /// * value: the target distance between the points
    sticks: HashMap<(usize, usize), f32>,
    /// How cloth sticks get generated
    pub stick_generation: StickGeneration,
}

impl Cloth {
    #[inline]
    pub fn new(fixed_points: impl Iterator<Item = usize>) -> Self {
        Self {
            fixed_points: fixed_points.collect(),
            current_point_positions: vec![],
            previous_point_positions: vec![],
            sticks: HashMap::new(),
            stick_generation: StickGeneration::default(),
        }
    }

    #[inline]
    #[must_use]
    pub fn is_setup(&self) -> bool {
        !self.current_point_positions.is_empty()
    }

    pub fn apply_to_mesh(&self, mesh: &mut Mesh, transform_matrix: &Mat4) {
        let matrix = transform_matrix.inverse();

        let positions: Vec<[f32; 3]> = self
            .current_point_positions
            .iter()
            .enumerate()
            .map(|(i, p)| {
                if self.fixed_points.contains(&i) {
                    p.to_array()
                } else {
                    matrix.transform_point3(*p).to_array()
                }
            })
            .collect();
        mesh.insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    }

    pub fn init_from_mesh(&mut self, mesh: &Mesh, transform_matrix: &Mat4) {
        let vertex_positions = mesh
            .attribute(Mesh::ATTRIBUTE_POSITION)
            .expect("Mesh associated to cloth doesn't have `ATTRIBUTE_POSITION` set");
        let positions: Vec<Vec3> = match vertex_positions {
            VertexAttributeValues::Float32x3(v) => v
                .iter()
                .map(|p| transform_matrix.transform_point3(Vec3::from(*p)))
                .collect(),
            _ => {
                panic!("Unsupported vertex position attribute, only `Float32x3` is supported");
            }
        };
        let indices: Vec<usize> = match mesh.indices() {
            None => {
                log::error!("Mesh associated to cloth doesn't have indices set");
                return;
            }
            Some(i) => match i {
                Indices::U16(v) => v.iter().map(|i| *i as usize).collect(),
                Indices::U32(v) => v.iter().map(|i| *i as usize).collect(),
            },
        };
        let mut sticks = HashMap::new();

        for truple in indices.chunks_exact(3) {
            let [a, b, c] = [truple[0], truple[1], truple[2]];
            let (p_a, p_b, p_c) = (positions[a], positions[b], positions[c]);
            if !sticks.contains_key(&(b, a)) {
                sticks.insert((a, b), p_a.distance(p_b));
            }
            if !sticks.contains_key(&(c, b)) {
                sticks.insert((b, c), p_b.distance(p_c));
            }
            if let StickGeneration::Triangles = self.stick_generation {
                if !sticks.contains_key(&(a, c)) {
                    sticks.insert((c, a), p_c.distance(p_a));
                }
            }
        }
        self.sticks = sticks;
        self.previous_point_positions = positions.clone();
        self.current_point_positions = positions;
    }

    pub fn update(&mut self, config: &ClothConfig, delta_time: f32, transform_matrix: &Mat4) {
        self.update_points(delta_time, config);
        self.update_sticks(config, transform_matrix);
    }

    fn update_points(&mut self, delta_time: f32, config: &ClothConfig) {
        let gravity = config.gravity * delta_time * delta_time;
        let friction = config.friction_coefficient();

        for (i, point) in self.current_point_positions.iter_mut().enumerate() {
            if !self.fixed_points.contains(&i) {
                let velocity = *point - self.previous_point_positions[i];
                self.previous_point_positions[i] = *point;
                *point += velocity * friction * delta_time + gravity;
            }
        }
    }

    fn update_sticks(&mut self, config: &ClothConfig, matrix: &Mat4) {
        for _depth in 0..config.sticks_computation_depth {
            for ((id_a, id_b), distance) in &self.sticks {
                let (position_a, fixed_a) = get_point!(
                    *id_a,
                    self.current_point_positions,
                    self.fixed_points,
                    matrix
                );
                let (position_b, fixed_b) = get_point!(
                    *id_b,
                    self.current_point_positions,
                    self.fixed_points,
                    matrix
                );
                let target_len = if fixed_a == fixed_b {
                    *distance / 2.0
                } else {
                    *distance
                };
                let center = (position_b + position_a) / 2.0;
                let direction = match (position_b - position_a).try_normalize() {
                    None => {
                        log::warn!("Failed handle stick between points {} and {} which are too close to each other", *id_a, *id_b);
                        continue;
                    }
                    Some(dir) => dir * target_len,
                };
                if !fixed_a {
                    self.current_point_positions[*id_a] = center + direction;
                }
                if !fixed_b {
                    self.current_point_positions[*id_b] = center - direction;
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mesh::rectangle_mesh;
    use bevy::prelude::Transform;

    mod init_from_mesh {
        use super::*;

        fn expected_stick_len(
            len: usize,
            generation: StickGeneration,
            (size_x, size_y): (usize, usize),
        ) {
            match generation {
                StickGeneration::Quads => {
                    assert_eq!(len, (size_x - 1) * size_y + (size_y - 1) * size_x);
                }
                StickGeneration::Triangles => {
                    assert_eq!(
                        len,
                        (size_x - 1) * size_y + (size_y - 1) * size_x + (size_x - 1) * (size_y - 1)
                    );
                }
            }
        }

        #[test]
        fn works_with_quads() {
            let mesh = rectangle_mesh(100, 100, Vec3::X, Vec3::Z);
            let matrix = Transform::default().compute_matrix();
            let mut cloth = Cloth::new(vec![].into_iter());
            cloth.stick_generation = StickGeneration::Quads; // QUADS
            cloth.init_from_mesh(&mesh, &matrix);
            assert_eq!(cloth.current_point_positions.len(), 100 * 100);
            assert_eq!(cloth.previous_point_positions.len(), 100 * 100);
            expected_stick_len(cloth.sticks.len(), cloth.stick_generation, (100, 100));
        }

        #[test]
        fn works_with_quads_2() {
            let mesh = rectangle_mesh(66, 42, Vec3::X, Vec3::Z);
            let matrix = Transform::default().compute_matrix();
            let mut cloth = Cloth::new(vec![].into_iter());
            cloth.stick_generation = StickGeneration::Quads; // QUADS
            cloth.init_from_mesh(&mesh, &matrix);
            assert_eq!(cloth.current_point_positions.len(), 66 * 42);
            assert_eq!(cloth.previous_point_positions.len(), 66 * 42);
            expected_stick_len(cloth.sticks.len(), cloth.stick_generation, (66, 42));
        }

        #[test]
        fn works_with_triangles() {
            let mesh = rectangle_mesh(100, 100, Vec3::X, Vec3::Z);
            let matrix = Transform::default().compute_matrix();
            let mut cloth = Cloth::new(vec![].into_iter());
            cloth.stick_generation = StickGeneration::Triangles; // TRIANGLES
            cloth.init_from_mesh(&mesh, &matrix);
            assert_eq!(cloth.current_point_positions.len(), 100 * 100);
            assert_eq!(cloth.previous_point_positions.len(), 100 * 100);
            expected_stick_len(cloth.sticks.len(), cloth.stick_generation, (100, 100));
        }

        #[test]
        fn works_with_triangles_2() {
            let mesh = rectangle_mesh(66, 42, Vec3::X, Vec3::Z);
            let matrix = Transform::default().compute_matrix();
            let mut cloth = Cloth::new(vec![].into_iter());
            cloth.stick_generation = StickGeneration::Triangles; // TRIANGLES
            cloth.init_from_mesh(&mesh, &matrix);
            assert_eq!(cloth.current_point_positions.len(), 66 * 42);
            assert_eq!(cloth.previous_point_positions.len(), 66 * 42);
            expected_stick_len(cloth.sticks.len(), cloth.stick_generation, (66, 42));
        }
    }
}
